{
  "hash": "da53ae4142b3ab1782999afd3f4ce6a4",
  "result": {
    "markdown": "---\nknit: quarto render\n---\n\n# Environments {#sec:environments}\n\nYour deck is now ready for a game of blackjack (or hearts or war), but are your `shuffle` and `deal` functions up to snuff? Definitely not. For example, `deal` deals the same card over and over again:\n\n```r\ndeal(deck)\n## face   suit value\n## king spades    13\n\ndeal(deck)\n## face   suit value\n## king spades    13\n\ndeal(deck)\n## face   suit value\n## king spades    13\n```\n\nAnd the `shuffle` function doesn't actually shuffle `deck` (it returns a copy of `deck` that has been shuffled). In short, both of these functions use `deck`, but neither manipulates `deck`—and we would like them to. \n\nTo fix these functions, you will need to learn how R stores, looks up, and manipulates objects like `deck`. R does all of these things with the help of an environment system.\n\n## Environments\n\nConsider for a moment how your computer stores files. Every file is saved in a folder, and each folder is saved in another folder, which forms a hierarchical file system. If your computer wants to open up a file, it must first look up the file in this file system.\n\nYou can see your file system by opening a finder window. For example, @fig:folders shows part of the file system on my computer. I have tons of folders. Inside one of them is a subfolder named _Documents_, inside of that subfolder is a sub-subfolder named _ggsubplot_, inside of that folder is a folder named _inst_, inside of that is a folder named _doc_, and inside of that is a file named _manual.pdf_.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![Your computer arranges files into a hierarchy of folders and subfolders. To look at a file, you need to find where it is saved in the file system.](images/hopr_0601.png){#fig:folders width=678}\n:::\n:::\n\nR uses a similar system to save R objects. Each object is saved inside of an environment, a list-like object that resembles a folder on your computer. Each environment is connected to a _parent environment_, a higher-level environment, which creates a hierarchy of environments. \n\nYou can see R's environment system with the `parenvs` function in the pryr package (note `parenvs` came in the pryr package when this book was first published). `parenvs(all = TRUE)` will return a list of the environments that your R session is using. The actual output will vary from session to session depending on which packages you have loaded. Here's the output from my current session:\n\n```r\nlibrary(pryr)\nparenvs(all = TRUE)\n##    label                            name               \n## 1  <environment: R_GlobalEnv>       \"\"                 \n## 2  <environment: package:pryr>  \"package:pryr\" \n## 3  <environment: 0x7fff3321c388>    \"tools:rstudio\"    \n## 4  <environment: package:stats>     \"package:stats\"    \n## 5  <environment: package:graphics>  \"package:graphics\" \n## 6  <environment: package:grDevices> \"package:grDevices\"\n## 7  <environment: package:utils>     \"package:utils\"    \n## 8  <environment: package:datasets>  \"package:datasets\" \n## 9  <environment: package:methods>   \"package:methods\"  \n## 10 <environment: 0x7fff3193dab0>    \"Autoloads\"        \n## 11 <environment: base>              \"\"                 \n## 12 <environment: R_EmptyEnv>        \"\"                 \n```\n\nIt takes some imagination to interpret this output, so let's visualize the environments as a system of folders, @fig:environments. You can think of the environment tree like this. The lowest-level environment is named `R_GlobalEnv` and is saved inside an environment named `package:pryr`, which is saved inside the environment named `0x7fff3321c388`, and so on, until you get to the final, highest-level environment, `R_EmptyEnv`. `R_EmptyEnv` is the only R environment that does not have a parent environment. \n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![R stores R objects in an environment tree that resembles your computer's folder system.](images/hopr_0602.png){#fig:environments width=578}\n:::\n:::\n\nRemember that this example is just a metaphor. R's environments exist in your RAM memory, and not in your file system. Also, R environments aren't technically saved inside one another. Each environment is connected to a parent environment, which makes it easy to search up R's environment tree. But this connection is one-way: there's no way to look at one environment and tell what its \"children\" are. So you cannot search down R's environment tree. In other ways, though, R's environment system works similar to a file system.\n\n## Working with Environments\n\nR comes with some helper functions that you can use to explore your environment tree. First, you can refer to any of the environments in your tree with `as.environment`. `as.environment` takes an environment name (as a character string) and returns the corresponding environment:\n\n```r\nas.environment(\"package:stats\")\n## <environment: package:stats>\n## attr(,\"name\")\n## [1] \"package:stats\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/stats\"\n```\n\nThree environments in your tree also come with their own accessor functions. These are the global environment (`R_GlobalEnv`), the base environment (`base`), and the empty environment (`R_EmptyEnv`). You can refer to them with:\n\n```r\nglobalenv()\n## <environment: R_GlobalEnv>\n\nbaseenv()\n## <environment: base>\n\nemptyenv()\n##<environment: R_EmptyEnv>\n```\n\nNext, you can look up an environment's parent with `parent.env`: \n\n```r\nparent.env(globalenv())\n## <environment: package:pryr>\n## attr(,\"name\")\n## [1] \"package:pryr\"\n## attr(,\"path\")\n## [1] \"/Library/Frameworks/R.framework/Versions/3.0/Resources/library/pryr\"\n```\n\nNotice that the empty environment is the only R environment without a parent:\n\n\n```r\nparent.env(emptyenv())\n## Error in parent.env(emptyenv()) : the empty environment has no parent\n```\n\nYou can view the objects saved in an environment with `ls` or `ls.str`. `ls` will return just the object names, but `ls.str` will display a little about each object's structure:\n\n```r\nls(emptyenv())\n## character(0)\n\nls(globalenv())\n##  \"deal\"    \"deck\"    \"deck2\"   \"deck3\"   \"deck4\"   \"deck5\"  \n##  \"die\"     \"gender\"  \"hand\"    \"lst\"     \"mat\"     \"mil\"    \n##  \"new\"     \"now\"     \"shuffle\" \"vec\"  \n```\n\nThe empty environment is—not surprisingly—empty; the base environment has too many objects to list here; and the global environment has some familiar faces. It is where R has saved all of the objects that you've created so far. \n\n::: {.callout-tip}\nRStudio's environment pane displays all of the objects in your global environment.\n:::\n\nYou can use R's `$` syntax to access an object in a specific environment. For example, you can access `deck` from the global environment:\n\n```r\nhead(globalenv()$deck, 3)\n##  face   suit value\n##  king spades    13\n## queen spades    12\n##  jack spades    11\n```\n\nAnd you can use the `assign` function to save an object into a particular environment. First give `assign` the name of the new object (as a character string). Then give `assign` the value of the new object, and finally the environment to save the object in:\n\n```r\nassign(\"new\", \"Hello Global\", envir = globalenv())\n\nglobalenv()$new\n## \"Hello Global\"\n```\n\nNotice that `assign` works similar to `<-`. If an object already exists with the given name in the given environment, `assign` will overwrite it without asking for permission. This makes `assign` useful for updating objects but creates the potential for heartache.\n\nNow that you can explore R's environment tree, let's examine how R uses it. R works closely with the environment tree to look up objects, store objects, and evaluate functions. How R does each of these tasks will depend on the current active environment.\n\n### The Active Environment\n\nAt any moment of time, R is working closely with a single environment. R will store new objects in this environment (if you create any), and R will use this environment as a starting point to look up existing objects (if you call any). I'll call this special environment the _active environment_. The active environment is usually the global environment, but this may change when you run a function.\n\nYou can use `environment` to see the current active environment:\n\n```r\nenvironment()\n<environment: R_GlobalEnv>\n```\n\nThe global environment plays a special role in R. It is the active environment for every command that you run at the command line. As a result, any object that you create at the command line will be saved in the global environment. You can think of the global environment as your user workspace.\n\nWhen you call an object at the command line, R will look for it first in the global environment. But what if the object is not there? In that case, R will follow a series of rules to look up the object.\n\n## Scoping Rules\n\nR follows a special set of rules to look up objects. These rules are known as R's scoping rules, and you've already met a couple of them: \n\n1. R looks for objects in the current active environment.\n2. When you work at the command line, the active environment is the global environment. Hence, R looks up objects that you call at the command line in the global environment.\n\nHere is a third rule that explains how R finds objects that are not in the active environment\n\n3. When R does not find an object in an environment, R looks in the environment's parent environment, then the parent of the parent, and so on, until R finds the object or reaches the empty environment.\n\nSo, if you call an object at the command line, R will look for it in the global environment. If R can't find it there, R will look in the parent of the global environment, and then the parent of the parent, and so on, working its way up the environment tree until it finds the object, as in @fig:path. If R cannot find the object in any environment, it will return an error that says the object is not found.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![R will search for an object by name in the active environment, here the global environment. If R does not find the object there, it will search in the active environment's parent, and then the parent's parent, and so on until R finds the object or runs out of environments.](images/hopr_0603.png){#fig:path width=713}\n:::\n:::\n\n::: {.callout-tip}\nRemember that functions are a type of object in R. R will store and look up functions the same way it stores and looks up other objects, by searching for them by name in the environment tree.\n:::\n\n## Assignment\n\nWhen you assign a value to an object, R saves the value in the active environment under the object's name. If an object with the same name already exists in the active environment, R will overwrite it.\n\nFor example, an object named `new` exists in the global environment:\n\n```r\nnew\n## \"Hello Global\"\n```\n\nYou can save a new object named `new` to the global environment with this command. R will overwrite the old object as a result:\n\n```r\nnew <- \"Hello Active\"\n\nnew\n## \"Hello Active\"\n```\n\nThis arrangement creates a quandary for R whenever R runs a function. Many functions save temporary objects that help them do their jobs. For example, the `roll` function from [Project 1: Weighted Dice](#sec:project-1) saved an object named `die` and an object named `dice`:\n\n```r\nroll <- function() {\n  die <- 1:6\n  dice <- sample(die, size = 2, replace = TRUE)\n  sum(dice)\n}\n```\n\nR must save these temporary objects in the active environment; but if R does that, it may overwrite existing objects. Function authors cannot guess ahead of time which names may already exist in your active environment. How does R avoid this risk? Every time R runs a function, it creates a new active environment to evaluate the function in.\n\n## Evaluation\n\nR creates a new environment _each_ time it evaluates a function. R will use the new environment as the active environment while it runs the function, and then R will return to the environment that you called the function from, bringing the function's result with it. Let's call these new environments _runtime environments_ because R creates them at runtime to evaluate functions.\n\nWe'll use the following function to explore R's runtime environments. We want to know what the environments look like: what are their parent environments, and what objects do they contain? `show_env` is designed to tell us: \n\n```r\nshow_env <- function(){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\n```\n\n`show_env` is itself a function, so when we call `show_env()`, R will create a runtime environment to evaluate the function in. The results of `show_env` will tell us the name of the runtime environment, its parent, and which objects the runtime environment contains:\n\n```r\nshow_env()\n## $ran.in\n## <environment: 0x7ff711d12e28>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n```\n\nThe results reveal that R created a new environment named `0x7ff711d12e28` to run `show_env()` in. The environment had no objects in it, and its parent was the `global environment`. So for purposes of running `show_env`, R's environment tree looked like @fig:tree.\n\nLet's run `show_env` again:\n\n```r\nshow_env()\n## $ran.in\n## <environment: 0x7ff715f49808>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n```\n\nThis time `show_env` ran in a new environment, `0x7ff715f49808`.  R creates a new environment _each_ time you run a function. The `0x7ff715f49808` environment looks exactly the same as `0x7ff711d12e28`. It is empty and has the same global environment as its parent.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![R creates a new environment to run show_env in. The environment is a child of the global environment.](images/hopr_0604.png){#fig:tree width=700}\n:::\n:::\n\nNow let's consider which environment R will use as the parent of the runtime environment. \n\nR will connect a function's runtime environment to the environment that the function _was first created in_. This environment plays an important role in the function's life—because all of the function's runtime environments will use it as a parent. Let's call this environment the _origin environment_. You can look up a function's origin environment by running `environment` on the function:\n\n```r\nenvironment(show_env)\n## <environment: R_GlobalEnv>\n```\n\nThe origin environment of `show_env` is the global environment because we created `show_env` at the command line, but the origin environment does not need to be the global environment. For example, the environment of `parenvs` is the `pryr` package: \n\n\n```r\nenvironment(parenvs)\n## <environment: namespace:pryr>\n```\n\nIn other words, the parent of a runtime environment will not always be the global environment; it will be whichever environment the function was first created in.\n\nFinally, let's look at the objects contained in a runtime environment. At the moment, `show_env`'s runtime environments do not contain any objects, but that is easy to fix. Just have `show_env` create some objects in its body of code. R will store any objects created by `show_env` in its runtime environment. Why? Because the runtime environment will be the active environment when those objects are created: \n\n```r\nshow_env <- function(){\n  a <- 1\n  b <- 2\n  c <- 3\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\n```\n\nThis time when we run `show_env`, R stores `a`, `b`, and `c` in the runtime environment:\n\n```r\nshow_env()\n## $ran.in\n## <environment: 0x7ff712312cd0>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n## a :  num 1\n## b :  num 2\n## c :  num 3\n```\n\nThis is how R ensures that a function does not overwrite anything that it shouldn't. Any objects created by the function are stored in a safe, out-of-the-way runtime environment.\n\nR will also put a second type of object in a runtime environment. If a function has arguments, R will copy over each argument to the runtime environment. The argument will appear as an object that has the name of the argument but the value of whatever input the user provided for the argument. This ensures that a function will be able to find and use each of its arguments:\n\n```r\nfoo <- \"take me to your runtime\"\n\nshow_env <- function(x = foo){\n  list(ran.in = environment(), \n    parent = parent.env(environment()), \n    objects = ls.str(environment()))\n}\n\nshow_env()\n## $ran.in\n## <environment: 0x7ff712398958>\n## \n## $parent\n## <environment: R_GlobalEnv>\n## \n## $objects\n## x :  chr \"take me to your runtime\"\n```\n\nLet's put this all together to see how R evaluates a function. Before you call a function, R is working in an active environment; let's call this the _calling environment_. It is the environment R calls the function from. \n\nThen you call the function. R responds by setting up a new runtime environment. This environment will be a child of the function's origin enviornment. R will copy each of the function's arguments into the runtime environment and then make the runtime environment the new active environment. \n\nNext, R runs the code in the body of the function. If the code creates any objects, R stores them in the active, that is, runtime environment. If the code calls any objects, R uses its scoping rules to look them up. R will search the runtime environment, then the parent of the runtime environment (which will be the origin environment), then the parent of the origin environment, and so on. Notice that the calling environment might not be on the search path. Usually, a function will only call its arguments, which R can find in the active runtime environment. \n\nFinally, R finishes running the function. It switches the active environment back to the calling environment. Now R executes any other commands in the line of code that called the function. So if you save the result of the function to an object with `<-`, the new object will be stored in the calling environment.\n\nTo recap, R stores its objects in an environment system. At any moment of time, R is working closely with a single active environment. It stores new objects in this environment, and it uses the environment as a starting point when it searches for existing objects. R's active environment is usually the global environment, but R will adjust the active environment to do things like run functions in a safe manner.\n\nHow can you use this knowledge to fix the `deal` and `shuffle` functions?\n\nFirst, let's start with a warm-up question. Suppose I redefine `deal` at the command line like this:\n\n```r\ndeal <- function() {\n  deck[1, ]\n}\n```\n\nNotice that `deal` no longer takes an argument, and it calls the `deck` object, which lives in the global environment.\n\n::: {#exr:will-deal-work name=\"Will deal work?\"}\nWill R be able to find `deck` and return an answer when I call the new version of `deal`, such as `deal()`?\n:::\n\n::: {.cell}\n\n```{.solution .cell-code}\nYes. `deal` will still work the same as before. R will run `deal` in a runtime environment that is a child of the global environment. Why will it be a child of the global environment? Because the global environment is the origin environment of `deal` (we defined `deal` in the global environment):\n```\n:::\n\n```r\nenvironment(deal)\n## <environment: R_GlobalEnv>\n```\n\nWhen `deal` calls `deck`, R will need to look up the `deck` object. R's scoping rules will lead it to the version of `deck` in the global environment, as in @fig:deal. `deal` works as expected as a result:\n\n```r\ndeal()\n##  face   suit value\n##  king spades    13\n```\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![R finds deck by looking in the parent of deal's runtime environment. The parent is the global environment, deal's origin environment. Here, R finds the copy of deck.](images/hopr_0605.png){#fig:deal width=746}\n:::\n:::\n\nNow let's fix the `deal` function to remove the cards it has dealt from `deck`. Recall that `deal` returns the top card of `deck` but does not remove the card from the deck. As a result, `deal` always returns the same card:\n\n```r\ndeal()\n##  face   suit value\n##  king spades    13\n\ndeal()\n##  face   suit value\n##  king spades    13\n```\n\nYou know enough R syntax to remove the top card of `deck`. The following code will save a prisitine copy of `deck` and then remove the top card:\n\n```r\nDECK <- deck\n\ndeck <- deck[-1, ]\n\nhead(deck, 3)\n##  face   suit value\n## queen spades    12\n##  jack spades    11\n##   ten spades    10\n```\n\nNow let's add the code to `deal`. Here `deal` saves (and then returns) the top card of `deck`. In between, it removes the card from `deck`...or does it?\n\n```r\ndeal <- function() {\n  card <- deck[1, ]\n  deck <- deck[-1, ]\n  card\n}\n```\n\nThis code won't work because R will be in a runtime environment when it executes `deck <- deck[-1, ]`. Instead of overwriting the global copy of `deck` with `deck[-1, ]`, `deal` will just create a slightly altered copy of `deck` in its runtime environment, as in @fig:second-deck.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![The deal function looks up deck in the global environment but saves deck[-1, ] in the runtime environment as a new object named deck. ](images/hopr_0606.png){#fig:second-deck width=590}\n:::\n:::\n\n::: {#exr:overwrite-deck name=\"Overwrite deck\"}\nRewrite the `deck <- deck[-1, ]` line of `deal` to _assign_ `deck[-1, ]` to an object named `deck` in the global environment. Hint: consider the `assign` function.\n:::\n\n::: {.cell}\n\n```{.solution .cell-code}\nYou can assign an object to a specific environment with the `assign` function: \n```\n:::\n\n```r\ndeal <- function() {\n  card <- deck[1, ]\n  assign(\"deck\", deck[-1, ], envir = globalenv())\n  card\n}\n```\n\nNow `deal` will finally clean up the global copy of `deck`, and we can `deal` cards just as we would in real life:\n\n```r\ndeal()\n##  face   suit value\n## queen spades    12\n\ndeal()\n## face   suit value\n## jack spades    11\n\ndeal()\n## face   suit value\n##  ten spades    10\n```\n\nLet's turn our attention to the `shuffle` function:\n\n```r\nshuffle <- function(cards) { \n  random <- sample(1:52, size = 52)\n  cards[random, ]\n}\n```\n\n`shuffle(deck)` doesn't shuffle the `deck` object; it returns a shuffled copy of the `deck` object:\n\n```r\nhead(deck, 3)\n##  face   suit value\n##  nine spades     9\n## eight spades     8\n## seven spades     7\n\na <- shuffle(deck)\n\nhead(deck, 3)\n##  face   suit value\n##  nine spades     9\n## eight spades     8\n## seven spades     7\n\nhead(a, 3)\n##  face     suit value\n##   ace diamonds     1\n## seven    clubs     7\n##   two    clubs     2\n```\n\nThis behavior is now undesirable in two ways. First, `shuffle` fails to shuffle `deck`. Second, `shuffle` returns a copy of `deck`, which may be missing the cards that have been dealt away. It would be better if `shuffle` returned the dealt cards to the deck and then shuffled. This is what happens when you shuffle a deck of cards in real life. \n\n:::{#exr:rewrite-shuffle name=\"Rewrite shuffle\"}\nRewrite `shuffle` so that it replaces the copy of `deck` that lives in the global environment with a shuffled version of `DECK`, the intact copy of `deck` that also lives in the global environment. The new version of `shuffle` should have no arguments and return no output.\n:::\n\n::: {.cell}\n\n```{.solution .cell-code}\nYou can update `shuffle` in the same way that you updated `deck`. The following version will do the job: \n```\n:::\n\n```r\nshuffle <- function(){\n  random <- sample(1:52, size = 52)\n  assign(\"deck\", DECK[random, ], envir = globalenv())\n}\n```\n\nSince `DECK` lives in the global environment, `shuffle`'s environment of origin, `shuffle` will be able to find `DECK` at runtime. R will search for `DECK` first in `shuffle`'s runtime environment, and then in `shuffle`'s origin environment—the global environment—which is where `DECK` is stored.\n\nThe second line of `shuffle` will create a reordered copy of `DECK` and save it as `deck` in the global environment. This will overwrite the previous, nonshuffled version of `deck`.\n\n## Closures\n\nOur system finally works. For example, you can shuffle the cards and then deal a hand of blackjack: \n\n```r\nshuffle()\n\ndeal()\n##  face   suit value\n## queen hearts    12\n\ndeal()\n##  face   suit value\n## eight hearts     8\n```\n\nBut the system requires `deck` and `DECK` to exist in the global environment. Lots of things happen in this environment, and it is possible that `deck` may get modified or erased by accident. \n\nIt would be better if we could store `deck` in a safe, out-of-the-way place, like one of those safe, out-of-the-way environments that R creates to run functions in. In fact, storing `deck` in a runtime environment is not such a bad idea.\n\nYou could create a function that takes `deck` as an argument and saves a copy of `deck` as `DECK`. The function could also save its own copies of `deal` and `shuffle`:\n\n```r\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = globalenv())\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = globalenv())\n }\n}\n```\n\nWhen you run `setup`, R will create a runtime environment to store these objects in. The environment will look like @fig:closure1.\n\nNow all of these things are safely out of the way in a child of the global environment. That makes them safe but hard to use. Let's ask `setup` to return `DEAL` and `SHUFFLE` so we can use them. The best way to do this is to return the functions as a list:\n\n\n```r\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = globalenv())\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = globalenv())\n }\n\n list(deal = DEAL, shuffle = SHUFFLE)\n}\n\ncards <- setup(deck)\n```\n\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![Running setup will store deck and DECK in an out-of-the-way place, and create a DEAL and SHUFFLE function. Each of these objects will be stored in an environment whose parent is the global environment.](images/hopr_0607.png){#fig:closure1 width=782}\n:::\n:::\n\nThen you can save each of the elements of the list to a dedicated object in the global environment:\n\n```r\ndeal <- cards$deal\nshuffle <- cards$shuffle\n```\n\nNow you can run `deal` and `shuffle` just as before. Each object contains the same code as the original `deal` and `shuffle`:\n\n```r\ndeal\n## function() {\n##     card <- deck[1, ]\n##     assign(\"deck\", deck[-1, ], envir = globalenv())\n##     card\n##   }\n## <environment: 0x7ff7169c3390>\n\nshuffle\n## function(){\n##     random <- sample(1:52, size = 52)\n##     assign(\"deck\", DECK[random, ], envir = globalenv())\n##  }\n## <environment: 0x7ff7169c3390>\n```\n\nHowever, the functions now have one important difference. Their origin environment is no longer the global environment (although `deal` and `shuffle` _are_ currently saved there). Their origin environment is the runtime environment that R made when you ran `setup`. That's where R created `DEAL` and `SHUFFLE`, the functions copied into the new `deal` and `shuffle`, as shown in: \n\n```r\nenvironment(deal)\n## <environment: 0x7ff7169c3390>\n\nenvironment(shuffle)\n## <environment: 0x7ff7169c3390>\n```\n\nWhy does this matter? Because now when you run `deal` or `shuffle`, R will evaluate the functions in a runtime environment that uses `0x7ff7169c3390` as its parent. `DECK` and `deck` will be in this parent environment, which means that `deal` and `shuffle` will be able to find them at runtime. `DECK` and `deck` will be in the functions' search path but still out of the way in every other respect, as shown in @fig:closure2.\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![Now deal and shuffle will be run in an environment that has the protected deck and DECK in its search path.](images/hopr_0608.png){#fig:closure2 width=782}\n:::\n:::\n\nThis arrangement is called a _closure_. `setup`'s runtime environment \"encloses\" the `deal` and `shuffle` functions. Both `deal` and `shuffle` can work closely with the objects contained in the enclosing environment, but almost nothing else can. The enclosing environment is not on the search path for any other R function or environment.\n\nYou may have noticed that `deal` and `shuffle` still update the `deck` object in the global environment. Don't worry, we're about to change that. We want `deal` and `shuffle` to work exclusively with the objects in the parent (enclosing) environment of their runtime environments. Instead of having each function reference the global environment to update `deck`, you can have them reference their parent environment at runtime, as shown in @fig:closure3:\n\n```r\nsetup <- function(deck) {\n  DECK <- deck\n\n  DEAL <- function() {\n    card <- deck[1, ]\n    assign(\"deck\", deck[-1, ], envir = parent.env(environment()))\n    card\n  }\n\n  SHUFFLE <- function(){\n    random <- sample(1:52, size = 52)\n    assign(\"deck\", DECK[random, ], envir = parent.env(environment()))\n }\n\n list(deal = DEAL, shuffle = SHUFFLE)\n}\n\ncards <- setup(deck)\ndeal <- cards$deal\nshuffle <- cards$shuffle\n```\n\n\n::: {.cell fig.alt='{}'}\n::: {.cell-output-display}\n![When you change your code, deal and shuffle will go from updating the global environment (left) to updating their parent environment (right).](images/hopr_0609.png){#fig:closure3 width=720}\n:::\n:::\n\nWe finally have a self-contained card game. You can delete (or modify) the global copy of `deck` as much as you want and still play cards. `deal` and `shuffle` will use the pristine, protected copy of `deck`:\n\n```r\nrm(deck)\n\nshuffle()\n\ndeal()\n## face   suit value\n##  ace hearts     1\n\ndeal()\n## face  suit value\n## jack clubs    11\n```\n\nBlackjack!\n\n\n## Summary\n\nR saves its objects in an environment system that resembles your computer's file system. If you understand this system, you can predict how R will look up objects. If you call an object at the command line, R will look for the object in the global environment and then the parents of the global environment, working its way up the environment tree one environment at a time. \n\nR will use a slightly different search path when you call an object from inside of a function. When you run a function, R creates a new environment to execute commands in. This environment will be a child of the environment where the function was originally defined. This may be the global environment, but it also may not be.  You can use this behavior to create closures, which are functions linked to objects in protected environments.\n\nAs you become familiar with R's environment system, you can use it to produce elegant results, like we did here. However, the real value of understanding the environment system comes from knowing how R functions do their job. You can use this knowledge to figure out what is going wrong when a function does not perform as expected.\n\n## Project 2 Wrap-up\n\nYou now have full control over the data sets and values that you load into R. You can store data as R objects, you can retrieve and manipulate data values at will, and you can even predict how R will store and look up your objects in your computer's memory.\n\nYou may not realize it yet, but your expertise makes you a powerful, computer-augmented data user. You can use R to save and work with larger data sets than you could otherwise handle. So far we've only worked with `deck`, a small data set; but you can use the same techniques to work with any data set that fits in your computer's memory.\n\nHowever, storing data is not the only logistical task that you will face as a data scientist. You will often want to do tasks with your data that are so complex or repetitive that they are difficult to do without a computer. Some of the things can be done with functions that already exist in R and its packages, but others cannot. You will be the most versatile as a data scientist if you can write your own programs for computers to follow. R can help you do this. When you are ready, [Project 3: Slot Machine](#sec:project-slots) will teach you the most useful skills for writing programs in R.",
    "supporting": [
      "environments_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "dependencies": {
      "type": "includes",
      "data": []
    },
    "preserve": {}
  }
}